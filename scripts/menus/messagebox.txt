class KeenMessage
{
	String text;
	int align;
	String graphic;
	int graphicalign;
	int width;
	int height;
	int autoclose;
	int fadeintime, fadeouttime;
	double fadealpha, fadetargetalpha;
	int showtics;

	ui static void Init(ClassicMessageBox parent, String mtext, int malign = 0, String mgraphic = "", int mgraphicalign = 0, int mautoclose = -1, int mwidth = 26, int mheight = 8, double fadealpha = 0.0, double fadetargetalpha = 1.0, int fadeintime = 0, int fadeouttime = 0)
	{
		KeenMessage msg = New("KeenMessage");

		msg.text = mtext;
		msg.align = malign;
		msg.graphic = mgraphic;
		msg.graphicalign = mgraphicalign;
		msg.autoclose = mautoclose;
		msg.width = mwidth;
		msg.height = mheight;
		msg.fadealpha = fadealpha;
		msg.fadetargetalpha = fadetargetalpha;
		msg.fadeintime = fadeintime;
		msg.fadeouttime = fadeouttime;
		msg.showtics = 15;

		parent.messages.Push(msg);
	}
}

class ClassicMessageBox : MessageBoxMenu
{
	String prefix;
	Color fillcolor;
	TextureID top, bottom, left, right;
	TextureID topleft, topright, bottomleft, bottomright;

	Font fnt;

	String message;
	int align;
	int graphicalign;
	String graphic;
	TextureID tex;
	int width, height;

	String cursor;
	int blinktime;

	bool silent;
	int autoclose;
	int cmds;

	int index;
	Array<KeenMessage> messages;

	int curstate;
	int fadetic, ticcount;
	int fadeintime, fadeouttime;
	double fadealpha, fadetargetalpha;

	int showtics;

	override void Init(Menu parent, String msg, int messagemode, bool playsound, Name cmd, voidptr native_handler)
	{
		silent = !playsound;

		// Initialize everything through the real message box code
		Super.Init(parent, msg, messagemode, playsound, cmd, native_handler);

		message = CleanString(msg);
		tex = TexMan.CheckForTexture(graphic, TexMan.Type_Any);

		if (!prefix.Length()) { prefix = "BG_"; fillcolor = 0x0; }
		if (!fnt) { fnt = BigFont; }

		top = TexMan.CheckForTexture(prefix .. "T", TexMan.Type_Any);
		bottom = TexMan.CheckForTexture(prefix .. "B", TexMan.Type_Any);
		left = TexMan.CheckForTexture(prefix .. "L", TexMan.Type_Any);
		right = TexMan.CheckForTexture(prefix .. "R", TexMan.Type_Any);
		topleft = TexMan.CheckForTexture(prefix .. "TL", TexMan.Type_Any);
		topright = TexMan.CheckForTexture(prefix .. "TR", TexMan.Type_Any);
		bottomleft = TexMan.CheckForTexture(prefix .. "BL", TexMan.Type_Any);
		bottomright = TexMan.CheckForTexture(prefix .. "BR", TexMan.Type_Any);

		if (messagemode > 0) { blinktime = -1; }

		autoclose = -1;
	}

	static String CleanString(String input)
	{
		input.Replace("\n\n" .. Stringtable.Localize("$DOSY"), "");
		input.Replace("\n\n" .. Stringtable.Localize("$PRESSKEY"), "");
		input.Replace("\n\n" .. Stringtable.Localize("$PRESSYN"), "");
		input.Replace(Stringtable.Localize("$PRESSYN"), ""); // For the save deletion prompt

		return input;
	}

	static ClassicMessageBox PrintMessage(String text, int align = 0, String graphic = "", int graphicalign = 0, int autoclose = -1, int width = 26, int height = 8, double fadealpha = 0.0, double fadetargetalpha = 1.0, int fadeintime = 0, int fadeouttime = 0)
	{
		ClassicMessageBox msg = ClassicMessageBox(GetCurrentMenu());

		if (!msg) { msg = New("ClassicMessageBox"); }

		msg.cmds = players[consoleplayer].cmd.buttons;

		msg.prefix = "B_";
		msg.fillcolor = 0xFFFFFF;
		msg.fnt = Font.GetFont("Classic");

		KeenMessage.Init(msg, text, align, graphic, graphicalign, autoclose, width * 8 + 16, height * 8 + 16, fadealpha, fadetargetalpha, fadeintime, fadeouttime);

		msg.Init(null, text, true, false);

		msg.index = 1;

		msg.message = msg.messages[msg.index - 1].text;
		msg.width = msg.messages[msg.index - 1].width;
		msg.height = msg.messages[msg.index - 1].height;
		msg.align = msg.messages[msg.index - 1].align;
		msg.graphic = msg.messages[msg.index - 1].graphic;
		msg.tex = TexMan.CheckForTexture(msg.graphic, TexMan.Type_Any);
		msg.graphicalign = msg.messages[msg.index - 1].graphicalign;
		msg.autoclose = msg.messages[msg.index - 1].autoclose;

		msg.curstate = 0;
		msg.fadeintime = msg.messages[msg.index - 1].fadeintime;
		msg.fadeouttime = msg.messages[msg.index - 1].fadeouttime;
		msg.fadealpha = msg.messages[msg.index - 1].fadealpha;
		msg.fadetargetalpha = msg.messages[msg.index - 1].fadetargetalpha;
		msg.fadetic = (msg.messages[msg.index - 1].fadeintime || msg.messages[msg.index - 1].fadeouttime) ? gametic : 0;

		msg.DontDim = true;
		msg.DontBlur = true;
		msg.silent = true;

		msg.showtics = 15;

		msg.ActivateMenu();

		return msg;
	}

	override void Drawer()
	{
		if (mParentMenu) { mParentMenu.Drawer(); }
		DrawMessage(message, 8, fillcolor);

		if (fadetic) { DrawFade(); }
	}

	override void Ticker()
	{
		if (showtics > 0) { showtics--; }

		if (autoclose > 0)
		{
			autoclose--;
		}
		else if (autoclose == 0)
		{
			index++;

			if (index > messages.Size())
			{
				if (!fadealpha)
				{
					Close();
				}
				else
				{
					menuactive = Menu.OnNoPause; // Let scripts (e.g., Level exit) run in the background
					if (index > messages.Size() + 1) { Close(); } // Then close the menu on the next tick
				}
			}
			else
			{
				message = messages[index - 1].text;
				width = messages[index - 1].width;
				height = messages[index - 1].height;
				align = messages[index - 1].align;
				graphic = messages[index - 1].graphic;
				tex = TexMan.CheckForTexture(graphic, TexMan.Type_Any);
				graphicalign = messages[index - 1].graphicalign;
				autoclose = messages[index - 1].autoclose;

				curstate = 0;
				fadeintime = messages[index - 1].fadeintime;
				fadeouttime = messages[index - 1].fadeouttime;
				fadealpha = messages[index - 1].fadealpha;
				fadetargetalpha = messages[index - 1].fadetargetalpha;
				fadetic = (messages[index - 1].fadeintime || messages[index - 1].fadeouttime) ? gametic : 0;
				showtics = messages[index - 1].showtics;

				cmds = players[consoleplayer].cmd.buttons;
			}

			if (!silent) { CloseSound(); }
		}

		if (fadetic) { TickFade(); }
	}

	void DrawMessage(String text, int size = 8, color clr = 0x0)
	{
		if (!top || !bottom || !left || !right || !topleft || !topright || !bottomleft || !bottomright) { return; }

		int w = 0, h = 0, gw = 0;
		text = StringTable.Localize(text);

		Vector2 graphicsize;

		if (graphic)
		{
			graphicsize = TexMan.GetScaledSize(tex);
			gw = int(graphicsize.x * CleanXFac);
		}

		BrokenLines message = fnt.BreakLines(text, (width > 0 ? width : 316) - int(graphicsize.x) - 20);

		int c = message.Count();

		int fontheight = fnt.GetHeight();

		for (int i = 0; i < c; i++)
		{
			w = max(w, message.StringWidth(i) + (i == (c - 1) ? blinktime > -1 ? fnt.StringWidth("_") : 0 : 0));
			h += fontheight;
		}

		int textheight = h;

		w += 24;
		h += 24;

		w = max(w, width);
		h = max(h, height);

		int ws = w * CleanXfac;
		int hs = h * CleanYfac;

		int x = Screen.GetWidth() / 2 - ws / 2;
		int y = Screen.GetHeight() / 2 - hs / 2;

		x += int(size * CleanXfac);
		y += int(size * CleanYfac);
		ws -= int(2 * size * CleanXfac);
		hs -= int(2 * size * CleanYfac);

		screen.Dim(clr, 1.0, x, y, ws, hs);

		screen.DrawTexture(top, true, x, y - int(size * CleanYfac), DTA_CleanNoMove, true, DTA_DestWidth, ws, DTA_DestHeight, int(size * CleanYfac));
		screen.DrawTexture(bottom, true, x, y + hs, DTA_CleanNoMove, true, DTA_DestWidth, ws, DTA_DestHeight, int(size * CleanYfac));
		screen.DrawTexture(left, true, x - int(size * CleanXfac), y, DTA_CleanNoMove, true, DTA_DestWidth, int(size * CleanXfac), DTA_DestHeight, hs);
		screen.DrawTexture(right, true, x + ws, y, DTA_CleanNoMove, true, DTA_DestWidth, int(size * CleanXfac), DTA_DestHeight, hs);

		screen.DrawTexture(topleft, true, x - int(size * CleanXfac), y - int(size * CleanYfac), DTA_CleanNoMove, true, DTA_DestWidth, int(size * CleanXfac), DTA_DestHeight, int(size * CleanYfac));
		screen.DrawTexture(topright, true, x + ws, y - int(size * CleanYfac), DTA_CleanNoMove, true, DTA_DestWidth, int(size * CleanXfac), DTA_DestHeight, int(size * CleanYfac));
		screen.DrawTexture(bottomleft, true, x - int(size * CleanXfac), y + hs, DTA_CleanNoMove, true, DTA_DestWidth, int(size * CleanXfac), DTA_DestHeight, int(size * CleanYfac));
		screen.DrawTexture(bottomright, true, x + ws, y + hs, DTA_CleanNoMove, true, DTA_DestWidth, int(size * CleanXfac), DTA_DestHeight, int(size * CleanYfac));

		int xoffset = 0;

		if (tex)
		{
			int drawx = x;

			if (graphicalign == 2) { drawx += ws / 2 - gw / 2; }
			else if (graphicalign == 1) { drawx += ws - gw; if (align) { xoffset -= int(graphicsize.x + 8) / align; } }
			else
			{
				if (align == 0) { xoffset += int(graphicsize.x) + 8; }
				else if (align == 2) { xoffset += int(graphicsize.x + 8) / 3; }
			}

			screen.DrawTexture(tex, true, drawx, y, DTA_CleanNoMove, true);
		}

		if (blinktime > -1 && gametic > blinktime)
		{
			if (cursor == "_") { cursor = ""; }
			else { cursor = "_"; }	

			blinktime = gametic + 5;
		}

		int drawx = 160 + xoffset;
		int drawy = 100 - textheight / 2;
		for (int i = 0; i < c; i++)
		{
			int size = fnt.StringWidth(message.StringAt(i) .. (i == (c - 1) ? cursor : ""));

			if (align == 2) { drawx -= size / 2; }
			else if (align == 1) { drawx += w / 2 - size - 8; }
			else { drawx -= w / 2 - 8; }

			screen.DrawText(fnt, 0, drawx, drawy, "\c[White]" .. message.StringAt(i) .. (i == (c - 1) ? cursor : ""), DTA_Clean, true);

			drawx = 160 + xoffset;
			drawy += fontheight;
		}
	}

	override bool OnUIEvent(UIEvent ev)
	{
		if (players[consoleplayer].cmd.buttons & cmds || showtics > 0) { return false; }

		if (ev.type == UIEvent.Type_KeyDown)
		{
			if (mMessageMode == 0)
			{
				// tolower
				int ch = ev.KeyChar;
				ch = ch >= 65 && ch < 91? ch + 32 : ch;

				if (ch == 110 /*'n'*/ || ch == 32) 
				{
					HandleResult(false);		
					return true;
				}
				else if (ch == 121 /*'y'*/) 
				{
					HandleResult(true);
					return true;
				}
			}
			else
			{
				autoclose = 2;
				return true;
			}
			return false;
		}
		return Super.OnUIEvent(ev);
	}

	override bool MenuEvent(int mkey, bool fromcontroller)
	{
		if (mMessageMode == 0)
		{
			if (mkey == MKEY_Up || mkey == MKEY_Down)
			{
				if (!silent) { MenuSound("menu/cursor"); }
				messageSelection = !messageSelection;
				return true;
			}
			else if (mkey == MKEY_Enter)
			{
				// 0 is yes, 1 is no
				HandleResult(!messageSelection);
				return true;
			}
			else if (mkey == MKEY_Back)
			{
				HandleResult(false);
				return true;
			}
			return false;
		}
		else
		{
			autoclose = 2;
			if (!silent) { CloseSound(); }
			return true;
		}

		return true;
	}

	override void HandleResult(bool res)
	{
		if (Handler != null)
		{
			if (res) 
			{
				CallHandler(Handler);
			}
			else
			{
				autoclose = 2;
				if (!silent) { CloseSound(); }
			}
		}
		else if (mParentMenu != NULL)
		{
			if (mMessageMode == 0)
			{
				if (mAction == 'None') 
				{
					mParentMenu.MenuEvent(res? MKEY_MBYes : MKEY_MBNo, false);
					autoclose = 2;
				}
				else
				{
					autoclose = 2;
					if (res) SetMenu(mAction, -1);
				}
				if (!silent) { CloseSound(); }
			}
		}
	}

	void DrawFade()
	{
		screen.Dim(0x000000, fadealpha, 0, 0, screen.GetWidth(), screen.GetHeight());
	}

	void TickFade()
	{
		ticcount++;

		switch (curstate)
		{
			case 0:
				if (fadeintime)
				{
					fadealpha = fadealpha + abs(clamp(fadetargetalpha / fadeintime, -1.0, 1.0));
				}

				if (ticcount >= fadeintime || !fadeintime)
				{
					ticcount = 0; curstate++;
				}
				break;
			case 1:
				fadealpha = fadetargetalpha;

				if (ticcount >= 24)
				{
					ticcount = 0;
					curstate++;
				}
				break;
			default:
				if (fadeouttime)
				{
					fadealpha = fadealpha - abs(clamp(fadetargetalpha / fadeouttime, -1.0, 1.0));
				}

				if (ticcount >= fadeouttime || !fadeouttime)
				{
					if (fadealpha == 0)
					{
						fadetic = 0;
					}
				}
				break;
		}
	}
}
