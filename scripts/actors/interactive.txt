/*

  Flatsprite floor/ceiling vent that is 0-height but walkable and solid.

  Most suitable for use as a breakable ceiling/floor vent, but can also have its
  pitch changed to match sloped surfaces, though the hitbox and blocking do not
  change, so the effect may not work quite as desired.

*/
class Debris_Vent_FloorCeiling : SwitchableDecoration
{
	Default
	{
		//$Category Special Effects (BoA)
		//$Title Vent Debris - Floor/Ceiling (activatable, solid/walkable)
		//$Color 12

		+SOLID
		+NOGRAVITY
		+ACTLIKEBRIDGE
		+FLATSPRITE
		+SHOOTABLE
		+DONTTHRUST
		+NOBLOOD
		+NOTAUTOAIMED
		Health 1;
		Height 0;
		Radius 32;
	}

	States
	{
		Spawn:
			VENT A 1;
		Active:
			VENT "#" 35;
			Wait;
		Inactive:
		Death:
			VENT B 0 {
				A_SpawnItemEx("PowerPlantSmokePuffSmall", 0, 0, 32, 0, 0, 0, 0, 0);

				if (level.time > 5) { S_Sound("DSMETDST", CHAN_AUTO, 0.5, ATTN_NORM); }

				for (int i = 0; i < 4; i++) {
					A_SpawnItemEx("Debris_Trash", 0, random(-32,32), random(0,64), random(-3,3), random(0,2), random(-1,4), 0, SXF_CLIENTSIDE);
					A_SpawnItemEx("Debris_Trash2", 0, random(-32,32), random(0,64), random(-3,3), random(0,2), random(-1,4), 0, SXF_CLIENTSIDE);
				}

				bNoInteraction = True;
			}
			VENT B -1;
			Stop;
	}

	override bool Used(Actor user)
	{
		SetStateLabel("Death");

		return Super.Used(user);
	}
}

class Debris_Wood_FloorCeiling : Debris_Vent_FloorCeiling
{
	Default
	{
		//$Title Wood Debris - Floor/Ceiling (activatable, solid/walkable)
	}

	States
	{
		Spawn:
			VENT C 1;
		Active:
			VENT "#" 35;
			Wait;
		Inactive:
		Death:
			VENT D 0 {
				A_SpawnItemEx("PowerPlantSmokePuffSmall", 0, 0, 32, 0, 0, 0, 0, 0);

				if (level.time > 5) { S_Sound("WOODBRK", CHAN_AUTO, 0.5, ATTN_NORM); }

				for (int i = 0; i < 4; i++) {
					A_SpawnItemEx("Debris_Wood", 0, random(-32,32), random(0,64), random(-3,3), random(0,2), random(-1,4), 0, SXF_CLIENTSIDE);
					A_SpawnItemEx("Debris_Wood", 0, random(-32,32), random(0,64), random(-3,3), random(0,2), random(-1,4), 0, SXF_CLIENTSIDE);
					A_SpawnItemEx("Debris_Wood", 0, random(-32,32), random(0,64), random(-3,3), random(0,2), random(-1,4), 0, SXF_CLIENTSIDE);
					A_SpawnItemEx("Debris_Wood", 0, random(-32,32), random(0,64), random(-3,3), random(0,2), random(-1,4), 0, SXF_CLIENTSIDE);
				}

				bNoInteraction = True;
			}
			VENT D -1;
			Stop;
	}
}

// Workaround for this bug: https://forum.zdoom.org/viewtopic.php?f=2&t=62967 - Model by Talon1024
class ManholeCover3D : Debris_Vent_FloorCeiling
{
	Default
	{
		//$Category Models (BoA)/Scenery
		//$Title Manhole Cover (3D)
		//$Color 3
		
		-SHOOTABLE
		+INVULNERABLE
		Height 2;
	}

	States
	{
		Spawn:
			MDLA A 1;
		Active:
			MDLA "#" 35;
			Wait;
		Inactive:
		Death:
			TNT1 A 0 {
				A_SpawnItemEx("PowerPlantSmokePuffSmall", 0, 0, 32, 0, 0, 0, 0, 0);

				if (level.time > 5) { S_Sound("DSMETDST", CHAN_AUTO, 0.5, ATTN_NORM); }

				for (int i = 0; i < 4; i++) {
					A_SpawnItemEx("Debris_Trash", 0, random(-32,32), random(0,64), random(-3,3), random(0,2), random(-1,4), 0, SXF_CLIENTSIDE);
					A_SpawnItemEx("Debris_Trash2", 0, random(-32,32), random(0,64), random(-3,3), random(0,2), random(-1,4), 0, SXF_CLIENTSIDE);
				}

				bNoInteraction = True;
			}
			TNT1 A -1;
			Stop;
	}

	// Only break these when shot, not when used.
	override bool Used(Actor user)
	{
		return false;
	}
}

class StatueBreakable : Actor
{
	double tiltangle;
	double tiltpitch;
	double floorheight;
	Actor item;
	Class<Actor> itemclass;
	Vector3 spawnoffset;
	Vector3 oldpos;
	double oldpitch;
	double oldroll;
	Sound slidesound;

	Property SlideSound:slidesound;

	Default
	{
		//$Category Props (BoA)/Interactive Items
		//$Title Breakable Statue (with configurable drop item)
		//$Arg0 "Thing ID to spawn"
		//$Arg0Str "Actor class to spawn"
		//$Arg0ToolTip "What actor to spawn.  Numeric values set Thing ID, and string values set spawn class.  \nDefaults to nothing spawned."
		//$Color 3

		Radius 24;
		Height 160;
		Health 50;
		Mass 2000;
		Pushfactor 0.05;
		Scale 0.5;
		+NOBLOOD
		+NOTAUTOAIMED
		+PUSHABLE
		+SHOOTABLE
		+SOLID
		+NODAMAGE

		StatueBreakable.SlideSound "stone/slide";
	}

	States
	{
		Spawn:
			MDLA A -1;
			Stop;
		Fall:
			MDLA A 1 A_DoTilt(tiltangle);
			Loop;
		Death:
			MDLA A -1
			{
				if (item)
				{
					item.bNoGravity = item.Default.bNoGravity;
					item.bSpecial = item.Default.bSpecial;
					item.bSolid = item.Default.bSolid;
					item.bShootable = item.Default.bShootable;

					item.angle = tiltangle + Random(70, 110) * RandomPick(-1, 1);
					item.pitch = 75;
					item.roll = 0;
					item.bFlatSprite = item.Default.bFlatSprite;
					item.bWallSprite = item.Default.bWallSprite;

					item.scale = item.Default.scale;

					item.SetOrigin((item.pos.xy + RotateVector((Default.Radius + Random(0, 16), 0), item.angle), item.floorz), true);

					item = null;
				}

				A_DoTilt(tiltangle, 90);
				bSolid = false;

				Vector3 centerpoint = pos + (RotateVector((Default.height / 2, 0), tiltangle), 0);

				for (int d = 0; d < 25; d++)
				{
					Actor mo = Spawn("DebrisChunk", centerpoint);
					if (mo)
					{
						DebrisChunk(mo).user_variant = RandomPick(12, 13, 14);
						mo.angle = Random(0, 359);
						mo.VelFromAngle(Random(2, 6), mo.angle);
					}
				}

				A_StartSound("misc/SRCRK2", CHAN_AUTO, 0, frandom (0.3,0.5), ATTN_NORM);

				Actor smoke = Spawn("KD_HL2SmokeGenerator", centerpoint);
				if (smoke)
				{
					smoke.scale = scale;
				}
			}
			Stop;
	}

	override void PostBeginPlay()
	{
		tiltangle = angle;

		itemclass = GetSpawnableType(args[0]);
		if (!itemclass) { itemclass = "Gem"; }

		if (itemclass)
		{
			item = Spawn(itemclass, pos + (RotateVector((13, -3), angle), 122));
			if (item)
			{
				item.master = self;

				item.bNoGravity = true;
				item.bSpecial = false;
				item.bSolid = false;
				item.bShootable = false;

				item.angle = angle - 11;

				item.pitch = -40;
				if (item.sprite != item.GetSpriteIndex("MDLA"))
				{
					item.pitch -= 90;

					double r = GetSpriteRadius(item);

					if (r > 5.0)
					{
						item.scale *= (5.0 / r);
					}
				}

				item.roll = -3;
				item.bWallSprite = false;
				item.bFlatSprite = true;

				spawnoffset = item.pos - pos;

				Vector2 temp = RotateVector((spawnoffset.x, spawnoffset.y), -angle);
				spawnoffset = (temp.x, temp.y, spawnoffset.z);

				oldpos = pos;
				oldpitch = pitch;
				oldroll = roll;
			}
		}

		Super.PostBeginPlay();
	}

	override void Tick()
	{
		floorheight = pos.z - cursector.floorplane.ZatPoint(pos.xy);

		if (BlockingLine && vel.xy.length() && floorheight > 0)
		{
			double linelength = int(BlockingLine.delta.Length());

			if (!BlockingLine.delta.x)
			{
				if (BlockingLine.v1.p.x > pos.x) { tiltangle = 180; }
				else { tiltangle = 0; }
			}
			else if (!BlockingLine.delta.y)
			{
				if (BlockingLine.v1.p.y > pos.y) { tiltangle = 270; }
				else { tiltangle = 90; }
			}
			else
			{
				tiltangle = atan2(BlockingLine.delta.y, BlockingLine.delta.x) + 90;
				if (BlockingLine.frontsector == cursector) { tiltangle += 180; }

				tiltangle = tiltangle % 360;
			}
		}

		if (vel.z < -10.0 && pos.z <= floorz + 16) { SetStateLabel("Death"); }
		if (pos.z == floorz && floorheight > 0) { SetStateLabel("Fall"); }

		if (
			item && 
			(
				pitch != oldpitch || 
				roll != oldroll || 
				pos != oldpos
			) && 
			!CheckSightOrRange(128)
		)
		{
			RotateItem();
		}

		double volume = 0.0;
		if (pos.z == floorz) { volume = vel.xy.length() / 25; }

		if (volume)
		{
			A_StartSound(slidesound, CHAN_5, CHANF_NOSTOP | CHANF_LOOP, volume);
			A_SoundVolume(CHAN_5, volume);
		}
		else
		{
			A_StopSound(CHAN_5);
		}

		Super.Tick();
	}

	void A_DoTilt(double tiltangle, double pitchinput = 0)
	{
		double angle = deltaangle(tiltangle, angle);

		if (tiltpitch < 90 || pitchinput)
		{
			if (pitchinput) { tiltpitch = pitchinput; }
			else { tiltpitch += max(1, tiltpitch / 30); }

			pitch = tiltpitch * cos(angle);
			roll = tiltpitch * sin(angle);
		}

		if (floorheight <= Default.radius / 2)
		{
			bSolid = false;
			bPushable = false;
		}

		VelFromAngle(0.25 * (90 - tiltpitch) / (Default.radius / 1.4), tiltangle);
	}

	void RotateItem()
	{
		Vector2 temp;
		Vector3 offset;

		// Keep the actor in the correct position, regardless of pitch/roll of the master actor
		if (item && spawnoffset != (0, 0, 0)) {
			temp = RotateVector((spawnoffset.y, spawnoffset.z), roll);
			offset = (spawnoffset.x, temp.x, temp.y);

			temp = RotateVector((offset.x, offset.z), 360 - pitch);
			offset = (temp.x, offset.y, temp.y);

			temp = RotateVector((offset.x, offset.y), angle);
			offset = (temp.x, temp.y, offset.z);

			item.SetOrigin(pos + offset, true);
		}

		oldpos = pos;
		oldpitch = pitch;
		oldroll = roll;
	}

	double GetSpriteRadius(Actor item)
	{
		TextureID tex = item.SpawnState.GetSpriteTexture(0);

		if (tex) {
			Vector2 size = TexMan.GetScaledSize(tex);
			Vector2 offset = TexMan.GetScaledOffset(tex);

			return max(size.x - offset.x, offset.x) * item.scale.x; // Get the width of the widest part of the sprite (left or right of the offset center)
		}

		return 0;
	}
}

class Gem : Inventory
{
	Default
	{
		//$Category Props (BoA)/Interactive Items

		+INVENTORY.INVBAR
		Alpha 0.95;
		RenderStyle "Add";
		Scale 0.5;
		Inventory.Icon "GEMAA0";
		Inventory.PickupSound "misc/k_pkup";
		Inventory.PickupMessage "$PUGEM";
	}

	States
	{
		Spawn:
			MDLA A -1 Light("MineralLite");
			Stop;
	}
}

class TextPaper : Actor
{
	String user_displaystring, user_displayimage;
	Sound pickupsound;

	Property PickupSound:pickupsound;

	Default
	{
		//$Category Props (BoA)/Interactive Items
		//$Title Paper (usable)
		//$Color 3

		//$Arg0 "Text ID"
		//$Arg0Tooltip "Predefined texts from the LANGUAGE lump, e.g. 2 is PAPERTEXT02.  Leave as 0 to use the user_displaytext property to set a string or LANGUAGE entry."
		//$Arg0Default 0
		//$Arg1 "Paper style"
		//$Arg1Tooltip "Various paper styles."
		//$Arg1Type 11
		//$Arg1Enum { 1 = "White Paper"; 2 = "Tan Paper"; 3 = "White Paper with Nazi Letterhead"; 4 = "Tan Paper with Nazi Letterhead"; 5 = "Old Dirty Paper"; 6 = "Heer Memo"; 7 = "Scrap"; 8 = "Astrostein tablet"; 0 = "Use user_displayimage variable"; }
		//$Arg1Default 1
		//$Arg2 "Font style"
		//$Arg2Tooltip "Various font styles."
		//$Arg2Type 11
		//$Arg2Enum { 1 = "Set Type (Book print)"; 2 = "Worn Typewriter"; 3 = "Occult Runes"; 4 = "Handwriting 1 (Messy)"; 5 = "Handwriting 2 (Neat)"; 6 = "Handwriting 3 (Neat, small)"; 7 = "Console Font"; 8 = "Maven Pro (small)"; }
		//$Arg2Default 2

		Radius 16;
		Height 32;
		Scale 0.25;
		RenderStyle 'Translucent';
		-SOLID
		+FLATSPRITE
		+NOGRAVITY
		TextPaper.PickupSound "pickup/papers";
	}

	States
	{
		Spawn:
			TEXT A -1;
			Stop;
	}

	override void PostBeginPlay()
	{
		frame = args[1];

		if (frame == 8) { PickupSound = "pickup/generic"; }

		Super.PostBeginPlay();
	}

	override bool Used(Actor user)
	{
		if (user)
		{
			user.player.ConversationNPC = self;
			if (user.player = players[consoleplayer]) { Menu.SetMenu("ViewItem"); }
			user.player.ConversationNPC = null;
		}

		return false;
	}
}

class TextPaperCollectible : Inventory
{
	String user_displaystring, user_displayimage;

	Default
	{
		//$Category Props (BoA)/Interactive Items
		//$Title Paper (usable, collectable)
		//$Color 3

		//$Arg0 "Text ID"
		//$Arg0Tooltip "Predefined texts from the LANGUAGE lump, e.g. 2 is PAPERTEXT02.  Leave as 0 to use the user_displaytext property to set a string or LANGUAGE entry."
		//$Arg0Default 0
		//$Arg1 "Paper style"
		//$Arg1Tooltip "Various paper styles."
		//$Arg1Type 11
		//$Arg1Enum { 1 = "White Paper"; 2 = "Tan Paper"; 3 = "White Paper with Nazi Letterhead"; 4 = "Tan Paper with Nazi Letterhead"; 5 = "Old Dirty Paper"; 6 = "Heer Memo"; 7 = "Scrap"; 8 = "Astrostein tablet"; 0 = "Use user_displayimage variable"; }
		//$Arg1Default 6
		//$Arg2 "Font style"
		//$Arg2Tooltip "Various font styles."
		//$Arg2Type 11
		//$Arg2Enum { 1 = "Set Type (Book print)"; 2 = "Worn Typewriter"; 3 = "Occult Runes"; 4 = "Handwriting 1 (Messy)"; 5 = "Handwriting 2 (Neat)"; 6 = "Handwriting 3 (Neat, small)"; 7 = "Console Font"; 8 = "Maven Pro (small)"; }
		//$Arg2Default 5

		-SOLID
		+FLATSPRITE
		+NOGRAVITY
		+INVENTORY.INVBAR
		+INVENTORY.AUTOACTIVATE

		Radius 16;
		Height 32;
		Scale 0.25;
		RenderStyle 'Translucent';
		Inventory.Icon "TEXTG0";
		Inventory.PickupMessage "$DOCUMENT";
		Inventory.PickupSound "pickup/papers";
	}

	States
	{
		Spawn:
			TEXT G -1;
			Stop;
	}

	override void PostBeginPlay()
	{
		frame = args[1];

		String ico = String.Format("%s%c%i", "TEXT", 65 + args[1], 0);
		icon = TexMan.CheckForTexture(ico, TexMan.Type_Any);

		if (frame == 8) { PickupSound = "pickup/generic"; }

		Super.PostBeginPlay();
	}

	override bool Use(bool pickup)
	{
		if (owner && owner.player)
		{
			owner.player.ConversationNPC = self;
			if (owner.player = players[consoleplayer]) { Menu.SetMenu("ViewItem"); }
			owner.player.ConversationNPC = null;
		}

		return false;
	}

	override bool HandlePickup (Inventory item)
	{
		return false; // Never stack these items together
	}

	override bool TryPickup(in out Actor toucher)
	{
		return false; // Don't pick this actor up automatically; use it like a regular TextPaper actor
	}

	override bool Used(Actor user)
	{
		Super.TryPickup(user);

		PrintPickupMessage(user.CheckLocalView(), PickupMessage());

		return false;
	}
}

class Safe : Actor
{
	bool isopen, locked, unlock;
	Class<Actor> spawnclass;

	Default
	{
		//$Category Props (BoA)/Interactive Items
		//$Arg0 "Script to run"
		//$Arg0Tooltip "[String] Actor to spawn in the safe or [Number] Script number to run"
		//$Arg0Str "Actor class to spawn"
		//$Arg1 "First number of combination"
		//$Arg2 "Second number of combination"
		//$Arg3 "Third number of combination"

		+SOLID
		Height 38;
		Radius 12;
	}

	States
	{
		Spawn:
		 	MDLA A -1;
			Stop;
		Opened:
			MDLA BCDE 5;
			MDLA F -1;
			Stop;
	}

	override void PostBeginPlay()
	{
		BoACompass.Add(self, "SAFEICO");

		if (args[0] < 0) // If a string value was passed in, use that as the spawn class
		{
			spawnclass = GetSpawnableType(args[0]);

			if (GetDefaultByType(spawnclass).bCountItem) { level.total_items++; }
		}

		locked = true;

		Super.PostBeginPlay();
	}

	override bool Used(Actor user)
	{
		if (isopen || !user.player) { return false; }

		if (locked)
		{
			user.player.ConversationNPC = self;
			if (user.player = players[consoleplayer]) { Menu.SetMenu("CombinationSafe"); }
			user.player.ConversationNPC = null;

			return true;
		}
		else
		{
			DoOpen();
			return true;
		}

		return false;
	}

	void DoOpen()
	{
		SetStateLabel("Opened");

		locked = false;
		isopen = true;

		A_SetSize(4);

		if (spawnclass) // If arg[0] resolved to a classname
		{
			// Spawn that actor
			let mo = Spawn(spawnclass, pos + (0, 0, 4), ALLOW_REPLACE);
			mo.scale *= 0.5;
			mo.bNoGravity = true;
			mo.bDropped = false;

			if (mo.bCountItem) { level.total_items--; }
		}
		else if (args[0] > 0)
		{
			// If you passed in a script number, then run the script
			ACS_ExecuteAlways(args[0], 0, tid);
		}

		BoACompass.Remove(self);
	}
}

mixin class GiveBuoyancy
{
	bool inwater;
	int offset;
	double user_buoyancy;

	Property Buoyancy:user_buoyancy;

	void DoBuoyancy()
	{
		if (!user_buoyancy) { return; }

		if (offset == 0) { offset = Random(-64, 64); }

		bool iswater;
		double waterheight;
		[waterheight, iswater] = GetWaterHeight();

		if (iswater && waterheight > floorz && pos.z < waterheight)
		{
			inwater = true;

			bNoGravity = true;
			bPushable = false;

			double heightoffset = min(abs(user_buoyancy) - 0.05, 0.1) * sin(level.time + offset);
			double waterclip = Default.height * ((1.0 - user_buoyancy) + heightoffset);

			if (waterheight > pos.z + waterclip + 1)
			{
				vel.z = 2.0 * abs(user_buoyancy);
			}
			else
			{
				SetOrigin((pos.xy, max(waterheight - waterclip, floorz)), true);
			}
		}
		else if (inwater)
		{
			inwater = false;

			bNoGravity = Default.bNoGravity;
			bPushable = Default.bPushable;
		}
	}

	// Modified from AActor::UpdateWaterLevel in p_mobj.cpp (waterlevel variable setting function)
	// Updated to return actual water height value
	double, bool GetWaterHeight()
	{
		if (curSector.MoreFlags & Sector.SECMF_UNDERWATER)
		{
			return ceilingz, true;
		}
		else
		{
			Sector hsec = curSector.GetHeightSec();

			if (hsec)
			{
				if (hsec.MoreFlags & Sector.SECMF_UNDERWATERMASK)
				{
					double fh = hsec.floorplane.ZatPoint(pos.xy);
					double ch = hsec.ceilingplane.ZatPoint(pos.xy);

					if (pos.z < fh)
					{
						return fh, true;
					}
					else if (!(hsec.MoreFlags & Sector.SECMF_FAKEFLOORONLY) && (pos.z + height > ch))
					{
						return ch, true;
					}
				}
			}
			else
			{
				for (int i = 0; i < curSector.Get3DFloorCount(); i++)
				{
					F3DFloor f = curSector.Get3DFloor(i);

					if (!(f.flags & F3DFloor.FF_EXISTS)) { continue; }
					if (f.flags & F3DFloor.FF_SOLID) { continue; }
					if (!(f.flags & F3DFloor.FF_SWIMMABLE)) { continue; }

					double ff_bottom = f.bottom.ZatPoint(pos.xy);
					double ff_top = f.top.ZatPoint(pos.xy);

					if (ff_bottom > pos.z + height) continue;

					return ff_top, true;
				}
			}
		}

		return 0, false;
	}
}