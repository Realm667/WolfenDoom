/*

  New Functions:
	GetLineTarget()
	- Saves reference to whatever actor is under the player's crosshair to the CrossHairTarget variable
	- Used by Status Bar code to draw boss health bars

	GetClosestForcedHealthBar()
	- Finds the closest Nazi class descendant with the user_DrawHealthBar variable set to true and saves 
	  a reference to that actor to the ForcedHealthBar variable
	- Used by Status Bar code to draw always-present health bar (e.g., Nebelwerfer in Paris)

	CountAlertedSneakables()
	- Stores the number of sneakable actors that are currently alerted to an ACS variable
	- Used internally by the status bar code to display the count of alerted sneakables

	DoTokenChecks()
	- Parent function where various inventory checks should be performed

	CheckSpriteToken(token name, standing sprite, [crouching sprite])
	- Handles sprite changing for Disguise Tokens:

		CheckSpriteToken("ScientistUniformToken", "PLSC", "PLYS")

	  This checks the player's inventory for the "ScientistUniformToken" token, and, if found, sets the 
	  base sprite to PLSC if the player is standing and PLYS if the player is crouching.  Also cancels
	  out the sprite squishing if you specify a crouch sprite
	- If you don't specify a crouching sprite, the standing sprite is used and default squishing applies

	SpawnEffect(class<PlayerEffect>)
	RemoveEffect(class<PlayerEffect>)
	- Used to spawn/remove an effect actor that follows the player around (e.g., glow for FireBrand)
	- See PlayerEffect class information below
	- Checks should be performed in DoTokenChecks:

		// If current weapon is BFG9000, spawn swirlysparkles that follow the player
		if (player && player.ReadyWeapon is "BFG9000") { SpawnEffect("SwirlySparkles"); }
		else { RemoveEffect("SwirlySparkles"); }

  New Base Classes:
	PlayerEffect
	- Base class for player effects, to be spawned/removed with SpawnEffect/RemoveEffect as shown above
	- Literally just a simple actor that constantly warps to the position of its master (the player)
	- Developer note: These actors have their statnum set to STAT_DEFAULT - 4 
	  (used to limit ThinkerIterator performance hit)
  
*/

class BoAPlayer : PlayerPawn
{
	double user_crouch;
	double user_ScaleY;
	int user_visibility;
	int suspicion;
	Actor CrosshairTarget;
	Actor ForcedHealthBar;
	SpriteID baseSprite;

	Default
	{
		+DONTBLAST // avoid kick's blast effect while kicking at walls
		+THRUSPECIES // Needed for swimming through SharkBlockers.
		Species "Player";
		Player.MaxHealth 100; // Needed for improved vitality serum
		Player.InvulnerabilityMode "reflective";
		Player.StartItem "KnifeSilent";
		Player.StartItem "TrenchShotgunLoaded",8;
		Player.StartItem "Browning5Loaded",4;
		Player.StartItem "MP40Loaded",32;
		Player.StartItem "G43Loaded",10;
		Player.StartItem "Walther9mmLoaded",8;
		Player.StartItem "Luger9mmLoaded",8;
		Player.StartItem "StenLoaded",32;
		Player.StartItem "Kar98kLoaded",5;
		Player.StartItem "PyrolightLoaded",25;
		Player.StartItem "PanzerschreckLoaded";
		Player.StartItem "AstroShotgunLoaded",8;
		Player.StartItem "AstroRocketLauncherLoaded",5;
		Player.StartItem "AstroChaingunLoaded",30;
		Player.StartItem "Stamina", 100;
		Player.ViewHeight 56;
		Player.AttackZOffset 24;
		Player.DisplayName "William Blazkowicz";
		Player.CrouchSprite "PLYC";
		Player.SideMove 1.0,0.5;
		Player.ForwardMove 1.0,0.5;
		Player.ViewBob 0.44;
		Player.WeaponSlot 1, "KnifeSilent", "Shovel", "Firebrand", "AstrosteinMelee";
		Player.WeaponSlot 2, "Luger9mm", "Walther9mm";
		Player.WeaponSlot 3, "TrenchShotgun", "Browning5", "AstroShotgun";
		Player.WeaponSlot 4, "MP40", "Sten", "AstroChaingun";
		Player.WeaponSlot 5, "Kar98k", "G43", "UMG43";
		Player.WeaponSlot 6, "Pyrolight", "Nebelwerfer", "AstroRocketlauncher";
		Player.WeaponSlot 7, "Panzerschreck";
		Player.WeaponSlot 8, "NullWeapon";
		Player.DamageScreenColor "ff ff ff", 1, "IceWater";
		Player.DamageScreenColor "64 00 C8", 1, "MutantPoison";
		DamageFactor "Creepy", 0.0;
		DamageFactor "FriendlyFrag", 0.5;
		Scale 0.65;
	}

	States
	{
	Spawn:
		PLAY A 0 DoTokenChecks(); // Must run the check once here because it can miss a frame somehow otherwise.  All other states are taken care of in the Tick function.
	SpawnLoop:
		"####" A 1;
		Loop;
	See:
		"####" AAAAAAAABBBBBBBBCCCCCCCCDDDDDDDD 1;
		Loop;
	Pain:
		"####" G 0 ACS_NamedExecuteWithResult("PlayerFlinch", 0);
		"####" G 4 A_Pain();
		"####" # 0 A_Jump(256, "SpawnLoop");
	Missile:
		"####" E 12;
		"####" # 0 A_Jump(256, "SpawnLoop");
	Melee:
		"####" F 6;
		"####" # 0 A_Jump(256, "Missile");
	Disintegrate: //here in order to transfer properly frames if needed - ozy81
		"####" G 0 A_Playsound("astrostein/guard_death");
		"####" G 5 A_PlayerScream();
		"####" G 0 A_NoBlocking;
		"####" G 0 A_SpawnItemEx("BaseLineSpawner", random(16, -16), random(16, -16), random(0, 8), 0, 0, random(1,3), 0, 129, 0);
		"####" GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG 1 A_FadeOut(0.02,0);
		TNT1 A -1 A_SetTranslucent(1);
		Stop;
	Death:
		"####" H 5 A_PlayerScream();
		"####" I 8;
		"####" I 1 A_PlaySound("death/bjfall");
		"####" J 5 A_NoBlocking;
		"####" K 5;
		"####" LM 2;
		"####" N -1;
		Stop;
	Death.Fire:
		TNT1 A 0 A_Jump(256,"Death.Fire.A","Death.Fire.B");
	Death.Fire.A:
		BURN A 5 BRIGHT Light("ITBURNS1");
		"####" BC 5 BRIGHT Light("ITBURNS1") A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,32), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160);
		"####" D 5 BRIGHT Light("ITBURNS1") A_PlaySound("death/burning");
		"####" E 5 BRIGHT Light("ITBURNS1") A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,32), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160);
		"####" FABCD 5 BRIGHT Light("ITBURNS2") A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,32), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160);
		"####" EFAG 5 BRIGHT Light("ITBURNS3");
		"####" H 5 BRIGHT Light("ITBURNS3") A_NoBlocking;
		"####" IJK 5 BRIGHT Light("ITBURNS2") A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,16), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160);
		"####" LMN 5 BRIGHT Light("ITBURNS1") A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,8), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160);
		"####" O -1;
		Stop;
	Death.Fire.B:
		NRUB A 5 BRIGHT Light("ITBURNS1");
		"####" BC 5 BRIGHT Light("ITBURNS1") A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,32), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160);
		"####" D 5 BRIGHT Light("ITBURNS1") A_PlaySound("death/burning");
		"####" E 5 BRIGHT Light("ITBURNS1") A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,32), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160);
		"####" FABCD 5 BRIGHT Light("ITBURNS2") A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,32), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160);
		"####" EFAG 5 BRIGHT Light("ITBURNS3");
		"####" H 5 BRIGHT Light("ITBURNS3") A_NoBlocking;
		"####" IJK 5 BRIGHT Light("ITBURNS2") A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,16), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160);
		"####" LMN 5 BRIGHT Light("ITBURNS1") A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,8), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160);
		"####" O -1;
		Stop;
	SpriteList:
		// Any sprite not used above that is switched to by a token check must be listed here or the game will not find it!
		PLSC A 0;
		PLYS A 0;
		SSOF A 0;
		Stop;
	}

	override void Tick()
	{
		if (Level.time % (35 * 5) == 0) { ForcedHealthBar = GetClosestForcedHealthBar(); } // Only run this check occasionally
		
		CrosshairTarget = GetLineTarget();

		DoTokenChecks();
		CountAlertedSneakables();

		Super.Tick();
	}

	Actor GetLineTarget()
	{
		FTranslatedLineTarget t;
		AimLineAttack(angle, 1024, t, 0.5);

		return t.linetarget;
	}

	Actor GetClosestForcedHealthBar()
	{
		ThinkerIterator Finder = ThinkerIterator.Create("Base", Thinker.STAT_DEFAULT - 3);
		Base it;
		Actor mo;

		while ( it = Base(Finder.Next()) )
		{
			if (!it.user_DrawHealthBar == True) { continue; } // Only process actors with the AlwaysDrawHealthBar flag set
			if (
				it.health <= 0 ||
				!it.bShootable ||
				it.bDormant
			) { continue; }
			if (mo && Distance3D(it) > Distance3D(mo)) { continue; } // Only draw health bar for the closest one

			mo = it;
		}

		return mo;
	}

	// Helper function for sprite index lookups to avoid hard engine crash
	SpriteID LookupSprite(Name spritecheck)
	{
		SpriteID temp = GetSpriteIndex(spritecheck);
		if (temp > -1) { return temp; }

		console.printf("\cgERROR: \cjThe sprite name index for '\cf%s\cj' could not be found.  Did you forget to add it to one of the actor's states?", spritecheck);
		return sprite;
	}

	// Function to do the actual token checking and sprite setting
	bool CheckSpriteToken(String token, Name standsprite, Name crouchsprite = "")
	{
		user_crouch = GetCrouchFactor(AAPTR_DEFAULT);

		if (CountInv(token) > 0)
		{
			if (!(crouchsprite == "") && user_crouch < 0.75)
			{
				sprite = LookupSprite(crouchsprite);
				Scale.Y = user_ScaleY / user_crouch; //Negate crouch sprite scaling
			}
			else
			{
				sprite = LookupSprite(standsprite);
				Scale.Y = user_ScaleY;
			}
			return true;
		}
		return false;
	}

	void DoTokenChecks()
	{
		if (health <= 0) { return; } // Don't change sprites if the player is dead

		if (user_ScaleY == 0) { user_ScaleY = Scale.Y; }
		if (!baseSprite) { baseSprite = sprite; }

		// Firebrand effect handling
		if (player && player.ReadyWeapon is "FireBrand" && CountInv("PowerWeaponLevel2") > 0) { SpawnEffect("FireBrandEffect"); }
		else { RemoveEffect("FireBrandEffect"); }

		// New uniform or other sprite-changing tokens should be set up here.  See CheckSpriteToken function above.
		//  These should be listed in order of precedence - The ones at the top will take priority.
		//  All new sprites need to be added to the 'SpriteList' state above or the engine won't be able to use them.
		if (
			CheckSpriteToken("SSBJUniformToken", "SSOF") || // Temporarily using the SS Officer Sprites (and just squishing them for crouch)
			CheckSpriteToken("ScientistUniformToken", "PLSC", "PLYS")
		) { return; }

		// If no tokens found, restore the base sprite and original scale
		sprite = baseSprite;
		Scale.Y = user_ScaleY;
	}

	// Function to spawn no more than a single copy of an effect actor as a child of the player
	void SpawnEffect(class<PlayerEffect> effect)
	{
		ThinkerIterator it = ThinkerIterator.Create("PlayerEffect", Thinker.STAT_DEFAULT - 4);
		PlayerEffect mo;

		while (mo = PlayerEffect(it.Next(true)))
		{
			if (mo.master && mo.master != self) { continue; } // Only look at effects that belong to this player actor
			if (mo is effect) { return; } // The effect already exists, so abort so we don't spawn it again
		}

		// If it wasn't already there, spawn this effect
		Actor new = Spawn(effect);
		if (new) { new.master = self; }
	}

	// Function to remove any spawned copy of an effect that is a child of the player
	void RemoveEffect(class<PlayerEffect> effect)
	{
		ThinkerIterator it = ThinkerIterator.Create("PlayerEffect", Thinker.STAT_DEFAULT - 4);
		PlayerEffect mo;

		while (mo = PlayerEffect(it.Next(true)))
		{
			if (mo.master && mo.master != self) { continue; } // Only look at effects that belong to this player actor
			if (mo is effect) { mo.SetStateLabel('null'); } // Remove the effect, if found
		}
	}

	void CountAlertedSneakables()
	{
		ThinkerIterator it = ThinkerIterator.Create("SneakableGuardEyesAlerted", Thinker.STAT_DEFAULT - 2);
		SneakableGuardEyesAlerted mo;

		int count;
		while (mo = SneakableGuardEyesAlerted(it.Next(true))) { count++; }

		ACS_NamedExecuteAlways("SetAlertedCount", 0, count);
	}
}

// Base class for simple visual effects that will always follow the player until removed
class PlayerEffect : Actor
{
	Default
	{
		+NOINTERACTION
	}

	States
	{
		Spawn:
			// This state should be replaced in child classes
			UNKN A 1;
			Loop;
	}

	override void BeginPlay()
	{
		ChangeStatNum(Thinker.STAT_DEFAULT - 4);
	}

	override void Tick()
	{
		// If a master is assigned, always move to its location
		if (master) { A_Warp(AAPTR_MASTER, flags:WARPF_COPYPITCH | WARPF_COPYINTERPOLATION | WARPF_NOCHECKPOSITION); }
		Super.Tick();
	}
}

class FireBrandEffect : PlayerEffect
{
	States
	{
		Spawn:
			TNT1 A 4 NoDelay Light("ITBURNSOC1");
			TNT1 A 4 Light("ITBURNSOC2");
		SpawnLoop:
			TNT1 A 4 Light("ITBURNSOC3") A_SetTics(Random(1, 8));
			Loop;
	}
}
